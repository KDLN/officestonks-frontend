{"ast":null,"code":"// WebSocket service for real-time updates\nimport { getToken } from './auth';\nlet socket = null;\nlet listeners = {};\nlet reconnectTimer = null;\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst RECONNECT_DELAY = 3000; // 3 seconds\n\n// Initialize WebSocket connection\nexport const initWebSocket = () => {\n  if (socket) {\n    // Close existing connection before creating a new one\n    socket.close();\n  }\n\n  // Socket will be initialized below\n\n  const token = getToken();\n  if (!token) {\n    console.error('No authentication token available for WebSocket connection');\n    return;\n  }\n\n  // Create WebSocket connection with token\n  // Get the backend URL from environment or default to Railway URL\n  const apiUrl = process.env.REACT_APP_API_URL || 'https://web-production-1e26.up.railway.app';\n\n  // Replace http/https with ws/wss\n  const wsBase = apiUrl.replace(/^http/, 'ws');\n\n  // Create the WebSocket URL\n  const wsUrl = `${wsBase}/ws?token=${token}`;\n  console.log('Connecting to WebSocket:', wsUrl);\n  socket = new WebSocket(wsUrl);\n\n  // Connection opened\n  socket.addEventListener('open', () => {\n    console.log('WebSocket connection established');\n    // Reset reconnect attempts on successful connection\n    reconnectAttempts = 0;\n    if (reconnectTimer) {\n      clearTimeout(reconnectTimer);\n      reconnectTimer = null;\n    }\n  });\n\n  // Listen for messages\n  socket.addEventListener('message', event => {\n    try {\n      // Log raw message for debugging\n      console.log('Raw WebSocket message:', event.data);\n\n      // Clean the message string\n      let jsonStr = event.data;\n      if (typeof jsonStr === 'string') {\n        // Remove any BOM and control characters\n        jsonStr = jsonStr.replace(/^\\ufeff/, ''); // Remove byte order mark\n        jsonStr = jsonStr.replace(/[\\x00-\\x1F\\x7F-\\x9F]/g, ''); // Remove control chars except whitespace\n        jsonStr = jsonStr.trim(); // Remove leading/trailing whitespace\n\n        // Backend should now send each message separately, but keep handling for robustness\n        if (jsonStr.includes('}{')) {\n          console.log('Found multiple JSON objects in message - splitting');\n\n          // Split by finding object boundaries - this handles nested objects better\n          let objects = [];\n          let nesting = 0;\n          let start = 0;\n          for (let i = 0; i < jsonStr.length; i++) {\n            if (jsonStr[i] === '{') {\n              if (nesting === 0) start = i;\n              nesting++;\n            } else if (jsonStr[i] === '}') {\n              nesting--;\n              if (nesting === 0) {\n                // Extract complete object\n                objects.push(jsonStr.substring(start, i + 1));\n              }\n            }\n          }\n          console.log(`Split into ${objects.length} JSON objects`);\n\n          // Process each message individually\n          objects.forEach(jsonObj => {\n            try {\n              const parsedObj = JSON.parse(jsonObj);\n              processMessage(parsedObj);\n            } catch (innerErr) {\n              console.error('Error parsing individual JSON object:', innerErr);\n              console.error('Object content:', jsonObj);\n            }\n          });\n          return; // We've handled the multiple objects\n        }\n      }\n\n      // Process a single JSON message\n      try {\n        const message = JSON.parse(jsonStr);\n        processMessage(message);\n      } catch (parseError) {\n        throw new Error(`Failed to parse JSON: ${parseError.message}`);\n      }\n    } catch (e) {\n      console.error('Error processing WebSocket message:', e);\n      console.error('Message content:', event.data);\n\n      // Final fallback attempt for malformed messages\n      try {\n        // Sometimes we might receive messages with extra characters or incorrect format\n        // Try to extract valid JSON objects using a regex\n        const messageStr = String(event.data);\n        const regex = /({[^}]+})/g;\n        const matches = messageStr.match(regex);\n        if (matches && matches.length > 0) {\n          console.log('Fallback: Found potential JSON objects:', matches.length);\n          matches.forEach(match => {\n            try {\n              // Try to clean and parse each match\n              const cleanMatch = match.replace(/[^\\x20-\\x7E]/g, '');\n              const parsedMsg = JSON.parse(cleanMatch);\n              console.log('Successfully parsed from fallback:', parsedMsg);\n              processMessage(parsedMsg);\n            } catch (matchErr) {\n              // Just log and continue\n              console.log('Failed to parse potential object:', match);\n            }\n          });\n        }\n      } catch (fallbackErr) {\n        console.error('All parsing attempts failed');\n      }\n    }\n  });\n\n  // Connection closed\n  socket.addEventListener('close', () => {\n    console.log('WebSocket connection closed');\n    // Attempt to reconnect\n    reconnect();\n  });\n\n  // Connection error\n  socket.addEventListener('error', error => {\n    console.error('WebSocket error:', error);\n    // Socket will automatically close after error\n  });\n  return socket;\n};\n\n// Helper function to process a single parsed message\nfunction processMessage(message) {\n  // Call all listeners for this message type\n  if (listeners[message.type]) {\n    listeners[message.type].forEach(callback => callback(message));\n  }\n\n  // Call general listeners\n  if (listeners['*']) {\n    listeners['*'].forEach(callback => callback(message));\n  }\n}\n\n// Add a listener for a specific message type\nexport const addListener = (type, callback) => {\n  if (!listeners[type]) {\n    listeners[type] = [];\n  }\n  listeners[type].push(callback);\n\n  // Return function to remove this listener\n  return () => {\n    if (listeners[type]) {\n      listeners[type] = listeners[type].filter(cb => cb !== callback);\n    }\n  };\n};\n\n// Remove a listener\nexport const removeListener = (type, callback) => {\n  if (listeners[type]) {\n    listeners[type] = listeners[type].filter(cb => cb !== callback);\n  }\n};\n\n// Close the WebSocket connection\nexport const closeWebSocket = () => {\n  if (socket) {\n    socket.close();\n    socket = null;\n  }\n\n  // Clear reconnect timer\n  if (reconnectTimer) {\n    clearTimeout(reconnectTimer);\n    reconnectTimer = null;\n  }\n\n  // Clear all listeners\n  listeners = {};\n};\n\n// Reconnect to WebSocket\nconst reconnect = () => {\n  if (reconnectTimer || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n      console.error(`Failed to reconnect after ${MAX_RECONNECT_ATTEMPTS} attempts`);\n    }\n    return;\n  }\n  reconnectAttempts++;\n  reconnectTimer = setTimeout(() => {\n    console.log(`Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);\n    reconnectTimer = null;\n    initWebSocket();\n  }, RECONNECT_DELAY);\n};","map":{"version":3,"names":["getToken","socket","listeners","reconnectTimer","reconnectAttempts","MAX_RECONNECT_ATTEMPTS","RECONNECT_DELAY","initWebSocket","close","token","console","error","apiUrl","process","env","REACT_APP_API_URL","wsBase","replace","wsUrl","log","WebSocket","addEventListener","clearTimeout","event","data","jsonStr","trim","includes","objects","nesting","start","i","length","push","substring","forEach","jsonObj","parsedObj","JSON","parse","processMessage","innerErr","message","parseError","Error","e","messageStr","String","regex","matches","match","cleanMatch","parsedMsg","matchErr","fallbackErr","reconnect","type","callback","addListener","filter","cb","removeListener","closeWebSocket","setTimeout"],"sources":["/home/kdln/code/officestonks/frontend/src/services/websocket.js"],"sourcesContent":["// WebSocket service for real-time updates\nimport { getToken } from './auth';\n\nlet socket = null;\nlet listeners = {};\nlet reconnectTimer = null;\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst RECONNECT_DELAY = 3000; // 3 seconds\n\n// Initialize WebSocket connection\nexport const initWebSocket = () => {\n  if (socket) {\n    // Close existing connection before creating a new one\n    socket.close();\n  }\n\n  // Socket will be initialized below\n\n  const token = getToken();\n  if (!token) {\n    console.error('No authentication token available for WebSocket connection');\n    return;\n  }\n\n  // Create WebSocket connection with token\n  // Get the backend URL from environment or default to Railway URL\n  const apiUrl = process.env.REACT_APP_API_URL || 'https://web-production-1e26.up.railway.app';\n\n  // Replace http/https with ws/wss\n  const wsBase = apiUrl.replace(/^http/, 'ws');\n\n  // Create the WebSocket URL\n  const wsUrl = `${wsBase}/ws?token=${token}`;\n\n  console.log('Connecting to WebSocket:', wsUrl);\n  socket = new WebSocket(wsUrl);\n\n  // Connection opened\n  socket.addEventListener('open', () => {\n    console.log('WebSocket connection established');\n    // Reset reconnect attempts on successful connection\n    reconnectAttempts = 0;\n    if (reconnectTimer) {\n      clearTimeout(reconnectTimer);\n      reconnectTimer = null;\n    }\n  });\n\n  // Listen for messages\n  socket.addEventListener('message', (event) => {\n    try {\n      // Log raw message for debugging\n      console.log('Raw WebSocket message:', event.data);\n\n      // Clean the message string\n      let jsonStr = event.data;\n      if (typeof jsonStr === 'string') {\n        // Remove any BOM and control characters\n        jsonStr = jsonStr.replace(/^\\ufeff/, ''); // Remove byte order mark\n        jsonStr = jsonStr.replace(/[\\x00-\\x1F\\x7F-\\x9F]/g, ''); // Remove control chars except whitespace\n        jsonStr = jsonStr.trim(); // Remove leading/trailing whitespace\n\n        // Backend should now send each message separately, but keep handling for robustness\n        if (jsonStr.includes('}{')) {\n          console.log('Found multiple JSON objects in message - splitting');\n\n          // Split by finding object boundaries - this handles nested objects better\n          let objects = [];\n          let nesting = 0;\n          let start = 0;\n\n          for (let i = 0; i < jsonStr.length; i++) {\n            if (jsonStr[i] === '{') {\n              if (nesting === 0) start = i;\n              nesting++;\n            } else if (jsonStr[i] === '}') {\n              nesting--;\n              if (nesting === 0) {\n                // Extract complete object\n                objects.push(jsonStr.substring(start, i + 1));\n              }\n            }\n          }\n\n          console.log(`Split into ${objects.length} JSON objects`);\n\n          // Process each message individually\n          objects.forEach(jsonObj => {\n            try {\n              const parsedObj = JSON.parse(jsonObj);\n              processMessage(parsedObj);\n            } catch (innerErr) {\n              console.error('Error parsing individual JSON object:', innerErr);\n              console.error('Object content:', jsonObj);\n            }\n          });\n\n          return; // We've handled the multiple objects\n        }\n      }\n\n      // Process a single JSON message\n      try {\n        const message = JSON.parse(jsonStr);\n        processMessage(message);\n      } catch (parseError) {\n        throw new Error(`Failed to parse JSON: ${parseError.message}`);\n      }\n    } catch (e) {\n      console.error('Error processing WebSocket message:', e);\n      console.error('Message content:', event.data);\n\n      // Final fallback attempt for malformed messages\n      try {\n        // Sometimes we might receive messages with extra characters or incorrect format\n        // Try to extract valid JSON objects using a regex\n        const messageStr = String(event.data);\n        const regex = /({[^}]+})/g;\n        const matches = messageStr.match(regex);\n\n        if (matches && matches.length > 0) {\n          console.log('Fallback: Found potential JSON objects:', matches.length);\n          matches.forEach(match => {\n            try {\n              // Try to clean and parse each match\n              const cleanMatch = match.replace(/[^\\x20-\\x7E]/g, '');\n              const parsedMsg = JSON.parse(cleanMatch);\n              console.log('Successfully parsed from fallback:', parsedMsg);\n              processMessage(parsedMsg);\n            } catch (matchErr) {\n              // Just log and continue\n              console.log('Failed to parse potential object:', match);\n            }\n          });\n        }\n      } catch (fallbackErr) {\n        console.error('All parsing attempts failed');\n      }\n    }\n  });\n  \n  // Connection closed\n  socket.addEventListener('close', () => {\n    console.log('WebSocket connection closed');\n    // Attempt to reconnect\n    reconnect();\n  });\n\n  // Connection error\n  socket.addEventListener('error', (error) => {\n    console.error('WebSocket error:', error);\n    // Socket will automatically close after error\n  });\n\n  return socket;\n};\n\n// Helper function to process a single parsed message\nfunction processMessage(message) {\n  // Call all listeners for this message type\n  if (listeners[message.type]) {\n    listeners[message.type].forEach(callback => callback(message));\n  }\n  \n  // Call general listeners\n  if (listeners['*']) {\n    listeners['*'].forEach(callback => callback(message));\n  }\n}\n\n// Add a listener for a specific message type\nexport const addListener = (type, callback) => {\n  if (!listeners[type]) {\n    listeners[type] = [];\n  }\n  listeners[type].push(callback);\n  \n  // Return function to remove this listener\n  return () => {\n    if (listeners[type]) {\n      listeners[type] = listeners[type].filter(cb => cb !== callback);\n    }\n  };\n};\n\n// Remove a listener\nexport const removeListener = (type, callback) => {\n  if (listeners[type]) {\n    listeners[type] = listeners[type].filter(cb => cb !== callback);\n  }\n};\n\n// Close the WebSocket connection\nexport const closeWebSocket = () => {\n  if (socket) {\n    socket.close();\n    socket = null;\n  }\n  \n  // Clear reconnect timer\n  if (reconnectTimer) {\n    clearTimeout(reconnectTimer);\n    reconnectTimer = null;\n  }\n  \n  // Clear all listeners\n  listeners = {};\n};\n\n// Reconnect to WebSocket\nconst reconnect = () => {\n  if (reconnectTimer || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n      console.error(`Failed to reconnect after ${MAX_RECONNECT_ATTEMPTS} attempts`);\n    }\n    return;\n  }\n  \n  reconnectAttempts++;\n  \n  reconnectTimer = setTimeout(() => {\n    console.log(`Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);\n    reconnectTimer = null;\n    initWebSocket();\n  }, RECONNECT_DELAY);\n};"],"mappings":"AAAA;AACA,SAASA,QAAQ,QAAQ,QAAQ;AAEjC,IAAIC,MAAM,GAAG,IAAI;AACjB,IAAIC,SAAS,GAAG,CAAC,CAAC;AAClB,IAAIC,cAAc,GAAG,IAAI;AACzB,IAAIC,iBAAiB,GAAG,CAAC;AACzB,MAAMC,sBAAsB,GAAG,CAAC;AAChC,MAAMC,eAAe,GAAG,IAAI,CAAC,CAAC;;AAE9B;AACA,OAAO,MAAMC,aAAa,GAAGA,CAAA,KAAM;EACjC,IAAIN,MAAM,EAAE;IACV;IACAA,MAAM,CAACO,KAAK,CAAC,CAAC;EAChB;;EAEA;;EAEA,MAAMC,KAAK,GAAGT,QAAQ,CAAC,CAAC;EACxB,IAAI,CAACS,KAAK,EAAE;IACVC,OAAO,CAACC,KAAK,CAAC,4DAA4D,CAAC;IAC3E;EACF;;EAEA;EACA;EACA,MAAMC,MAAM,GAAGC,OAAO,CAACC,GAAG,CAACC,iBAAiB,IAAI,4CAA4C;;EAE5F;EACA,MAAMC,MAAM,GAAGJ,MAAM,CAACK,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC;;EAE5C;EACA,MAAMC,KAAK,GAAG,GAAGF,MAAM,aAAaP,KAAK,EAAE;EAE3CC,OAAO,CAACS,GAAG,CAAC,0BAA0B,EAAED,KAAK,CAAC;EAC9CjB,MAAM,GAAG,IAAImB,SAAS,CAACF,KAAK,CAAC;;EAE7B;EACAjB,MAAM,CAACoB,gBAAgB,CAAC,MAAM,EAAE,MAAM;IACpCX,OAAO,CAACS,GAAG,CAAC,kCAAkC,CAAC;IAC/C;IACAf,iBAAiB,GAAG,CAAC;IACrB,IAAID,cAAc,EAAE;MAClBmB,YAAY,CAACnB,cAAc,CAAC;MAC5BA,cAAc,GAAG,IAAI;IACvB;EACF,CAAC,CAAC;;EAEF;EACAF,MAAM,CAACoB,gBAAgB,CAAC,SAAS,EAAGE,KAAK,IAAK;IAC5C,IAAI;MACF;MACAb,OAAO,CAACS,GAAG,CAAC,wBAAwB,EAAEI,KAAK,CAACC,IAAI,CAAC;;MAEjD;MACA,IAAIC,OAAO,GAAGF,KAAK,CAACC,IAAI;MACxB,IAAI,OAAOC,OAAO,KAAK,QAAQ,EAAE;QAC/B;QACAA,OAAO,GAAGA,OAAO,CAACR,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC,CAAC;QAC1CQ,OAAO,GAAGA,OAAO,CAACR,OAAO,CAAC,uBAAuB,EAAE,EAAE,CAAC,CAAC,CAAC;QACxDQ,OAAO,GAAGA,OAAO,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC;;QAE1B;QACA,IAAID,OAAO,CAACE,QAAQ,CAAC,IAAI,CAAC,EAAE;UAC1BjB,OAAO,CAACS,GAAG,CAAC,oDAAoD,CAAC;;UAEjE;UACA,IAAIS,OAAO,GAAG,EAAE;UAChB,IAAIC,OAAO,GAAG,CAAC;UACf,IAAIC,KAAK,GAAG,CAAC;UAEb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,OAAO,CAACO,MAAM,EAAED,CAAC,EAAE,EAAE;YACvC,IAAIN,OAAO,CAACM,CAAC,CAAC,KAAK,GAAG,EAAE;cACtB,IAAIF,OAAO,KAAK,CAAC,EAAEC,KAAK,GAAGC,CAAC;cAC5BF,OAAO,EAAE;YACX,CAAC,MAAM,IAAIJ,OAAO,CAACM,CAAC,CAAC,KAAK,GAAG,EAAE;cAC7BF,OAAO,EAAE;cACT,IAAIA,OAAO,KAAK,CAAC,EAAE;gBACjB;gBACAD,OAAO,CAACK,IAAI,CAACR,OAAO,CAACS,SAAS,CAACJ,KAAK,EAAEC,CAAC,GAAG,CAAC,CAAC,CAAC;cAC/C;YACF;UACF;UAEArB,OAAO,CAACS,GAAG,CAAC,cAAcS,OAAO,CAACI,MAAM,eAAe,CAAC;;UAExD;UACAJ,OAAO,CAACO,OAAO,CAACC,OAAO,IAAI;YACzB,IAAI;cACF,MAAMC,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACH,OAAO,CAAC;cACrCI,cAAc,CAACH,SAAS,CAAC;YAC3B,CAAC,CAAC,OAAOI,QAAQ,EAAE;cACjB/B,OAAO,CAACC,KAAK,CAAC,uCAAuC,EAAE8B,QAAQ,CAAC;cAChE/B,OAAO,CAACC,KAAK,CAAC,iBAAiB,EAAEyB,OAAO,CAAC;YAC3C;UACF,CAAC,CAAC;UAEF,OAAO,CAAC;QACV;MACF;;MAEA;MACA,IAAI;QACF,MAAMM,OAAO,GAAGJ,IAAI,CAACC,KAAK,CAACd,OAAO,CAAC;QACnCe,cAAc,CAACE,OAAO,CAAC;MACzB,CAAC,CAAC,OAAOC,UAAU,EAAE;QACnB,MAAM,IAAIC,KAAK,CAAC,yBAAyBD,UAAU,CAACD,OAAO,EAAE,CAAC;MAChE;IACF,CAAC,CAAC,OAAOG,CAAC,EAAE;MACVnC,OAAO,CAACC,KAAK,CAAC,qCAAqC,EAAEkC,CAAC,CAAC;MACvDnC,OAAO,CAACC,KAAK,CAAC,kBAAkB,EAAEY,KAAK,CAACC,IAAI,CAAC;;MAE7C;MACA,IAAI;QACF;QACA;QACA,MAAMsB,UAAU,GAAGC,MAAM,CAACxB,KAAK,CAACC,IAAI,CAAC;QACrC,MAAMwB,KAAK,GAAG,YAAY;QAC1B,MAAMC,OAAO,GAAGH,UAAU,CAACI,KAAK,CAACF,KAAK,CAAC;QAEvC,IAAIC,OAAO,IAAIA,OAAO,CAACjB,MAAM,GAAG,CAAC,EAAE;UACjCtB,OAAO,CAACS,GAAG,CAAC,yCAAyC,EAAE8B,OAAO,CAACjB,MAAM,CAAC;UACtEiB,OAAO,CAACd,OAAO,CAACe,KAAK,IAAI;YACvB,IAAI;cACF;cACA,MAAMC,UAAU,GAAGD,KAAK,CAACjC,OAAO,CAAC,eAAe,EAAE,EAAE,CAAC;cACrD,MAAMmC,SAAS,GAAGd,IAAI,CAACC,KAAK,CAACY,UAAU,CAAC;cACxCzC,OAAO,CAACS,GAAG,CAAC,oCAAoC,EAAEiC,SAAS,CAAC;cAC5DZ,cAAc,CAACY,SAAS,CAAC;YAC3B,CAAC,CAAC,OAAOC,QAAQ,EAAE;cACjB;cACA3C,OAAO,CAACS,GAAG,CAAC,mCAAmC,EAAE+B,KAAK,CAAC;YACzD;UACF,CAAC,CAAC;QACJ;MACF,CAAC,CAAC,OAAOI,WAAW,EAAE;QACpB5C,OAAO,CAACC,KAAK,CAAC,6BAA6B,CAAC;MAC9C;IACF;EACF,CAAC,CAAC;;EAEF;EACAV,MAAM,CAACoB,gBAAgB,CAAC,OAAO,EAAE,MAAM;IACrCX,OAAO,CAACS,GAAG,CAAC,6BAA6B,CAAC;IAC1C;IACAoC,SAAS,CAAC,CAAC;EACb,CAAC,CAAC;;EAEF;EACAtD,MAAM,CAACoB,gBAAgB,CAAC,OAAO,EAAGV,KAAK,IAAK;IAC1CD,OAAO,CAACC,KAAK,CAAC,kBAAkB,EAAEA,KAAK,CAAC;IACxC;EACF,CAAC,CAAC;EAEF,OAAOV,MAAM;AACf,CAAC;;AAED;AACA,SAASuC,cAAcA,CAACE,OAAO,EAAE;EAC/B;EACA,IAAIxC,SAAS,CAACwC,OAAO,CAACc,IAAI,CAAC,EAAE;IAC3BtD,SAAS,CAACwC,OAAO,CAACc,IAAI,CAAC,CAACrB,OAAO,CAACsB,QAAQ,IAAIA,QAAQ,CAACf,OAAO,CAAC,CAAC;EAChE;;EAEA;EACA,IAAIxC,SAAS,CAAC,GAAG,CAAC,EAAE;IAClBA,SAAS,CAAC,GAAG,CAAC,CAACiC,OAAO,CAACsB,QAAQ,IAAIA,QAAQ,CAACf,OAAO,CAAC,CAAC;EACvD;AACF;;AAEA;AACA,OAAO,MAAMgB,WAAW,GAAGA,CAACF,IAAI,EAAEC,QAAQ,KAAK;EAC7C,IAAI,CAACvD,SAAS,CAACsD,IAAI,CAAC,EAAE;IACpBtD,SAAS,CAACsD,IAAI,CAAC,GAAG,EAAE;EACtB;EACAtD,SAAS,CAACsD,IAAI,CAAC,CAACvB,IAAI,CAACwB,QAAQ,CAAC;;EAE9B;EACA,OAAO,MAAM;IACX,IAAIvD,SAAS,CAACsD,IAAI,CAAC,EAAE;MACnBtD,SAAS,CAACsD,IAAI,CAAC,GAAGtD,SAAS,CAACsD,IAAI,CAAC,CAACG,MAAM,CAACC,EAAE,IAAIA,EAAE,KAAKH,QAAQ,CAAC;IACjE;EACF,CAAC;AACH,CAAC;;AAED;AACA,OAAO,MAAMI,cAAc,GAAGA,CAACL,IAAI,EAAEC,QAAQ,KAAK;EAChD,IAAIvD,SAAS,CAACsD,IAAI,CAAC,EAAE;IACnBtD,SAAS,CAACsD,IAAI,CAAC,GAAGtD,SAAS,CAACsD,IAAI,CAAC,CAACG,MAAM,CAACC,EAAE,IAAIA,EAAE,KAAKH,QAAQ,CAAC;EACjE;AACF,CAAC;;AAED;AACA,OAAO,MAAMK,cAAc,GAAGA,CAAA,KAAM;EAClC,IAAI7D,MAAM,EAAE;IACVA,MAAM,CAACO,KAAK,CAAC,CAAC;IACdP,MAAM,GAAG,IAAI;EACf;;EAEA;EACA,IAAIE,cAAc,EAAE;IAClBmB,YAAY,CAACnB,cAAc,CAAC;IAC5BA,cAAc,GAAG,IAAI;EACvB;;EAEA;EACAD,SAAS,GAAG,CAAC,CAAC;AAChB,CAAC;;AAED;AACA,MAAMqD,SAAS,GAAGA,CAAA,KAAM;EACtB,IAAIpD,cAAc,IAAIC,iBAAiB,IAAIC,sBAAsB,EAAE;IACjE,IAAID,iBAAiB,IAAIC,sBAAsB,EAAE;MAC/CK,OAAO,CAACC,KAAK,CAAC,6BAA6BN,sBAAsB,WAAW,CAAC;IAC/E;IACA;EACF;EAEAD,iBAAiB,EAAE;EAEnBD,cAAc,GAAG4D,UAAU,CAAC,MAAM;IAChCrD,OAAO,CAACS,GAAG,CAAC,4BAA4Bf,iBAAiB,IAAIC,sBAAsB,MAAM,CAAC;IAC1FF,cAAc,GAAG,IAAI;IACrBI,aAAa,CAAC,CAAC;EACjB,CAAC,EAAED,eAAe,CAAC;AACrB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}