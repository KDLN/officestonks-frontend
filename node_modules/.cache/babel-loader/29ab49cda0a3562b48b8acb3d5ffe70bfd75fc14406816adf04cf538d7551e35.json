{"ast":null,"code":"// WebSocket service for real-time updates\nimport { getToken } from './auth';\nlet socket = null;\nlet listeners = {};\nlet reconnectTimer = null;\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst RECONNECT_DELAY = 3000; // 3 seconds\n\n// Initialize WebSocket connection\nexport const initWebSocket = () => {\n  if (socket) {\n    // Close existing connection before creating a new one\n    socket.close();\n  }\n  const token = getToken();\n  if (!token) {\n    console.error('No authentication token available for WebSocket connection');\n    return;\n  }\n\n  // Create WebSocket connection with token\n  // Get the backend URL from environment or default to Railway URL\n  const apiUrl = process.env.REACT_APP_API_URL || 'https://web-production-1e26.up.railway.app';\n\n  // Replace http/https with ws/wss\n  const wsBase = apiUrl.replace(/^http/, 'ws');\n\n  // Create the WebSocket URL\n  const wsUrl = `${wsBase}/ws?token=${token}`;\n  console.log('Connecting to WebSocket:', wsUrl);\n  socket = new WebSocket(wsUrl);\n\n  // Connection opened\n  socket.addEventListener('open', () => {\n    console.log('WebSocket connection established');\n    // Reset reconnect attempts on successful connection\n    reconnectAttempts = 0;\n    if (reconnectTimer) {\n      clearTimeout(reconnectTimer);\n      reconnectTimer = null;\n    }\n  });\n\n  // Listen for messages\n  socket.addEventListener('message', event => {\n    try {\n      // Log raw message for debugging\n      console.log('Raw WebSocket message:', event.data);\n\n      // Clean up the message if needed (in case there are control characters)\n      let jsonStr = event.data;\n      if (typeof jsonStr === 'string') {\n        // Remove any BOM and control characters\n        jsonStr = jsonStr.replace(/^\\ufeff/, ''); // Remove byte order mark\n        jsonStr = jsonStr.replace(/[\\x00-\\x1F\\x7F-\\x9F]/g, ''); // Remove control chars\n      }\n      const message = JSON.parse(jsonStr);\n\n      // Call all listeners for this message type\n      if (listeners[message.type]) {\n        listeners[message.type].forEach(callback => callback(message));\n      }\n\n      // Call general listeners\n      if (listeners['*']) {\n        listeners['*'].forEach(callback => callback(message));\n      }\n    } catch (e) {\n      console.error('Error parsing WebSocket message', e);\n      console.error('Message content:', event.data);\n      // Continue - don't let the error stop the socket\n    }\n  });\n\n  // Connection closed\n  socket.addEventListener('close', () => {\n    console.log('WebSocket connection closed');\n    // Attempt to reconnect\n    reconnect();\n  });\n\n  // Connection error\n  socket.addEventListener('error', error => {\n    console.error('WebSocket error:', error);\n    // Socket will automatically close after error\n  });\n  return socket;\n};\n\n// Add a listener for a specific message type\nexport const addListener = (type, callback) => {\n  if (!listeners[type]) {\n    listeners[type] = [];\n  }\n  listeners[type].push(callback);\n\n  // Return function to remove this listener\n  return () => {\n    if (listeners[type]) {\n      listeners[type] = listeners[type].filter(cb => cb !== callback);\n    }\n  };\n};\n\n// Remove a listener\nexport const removeListener = (type, callback) => {\n  if (listeners[type]) {\n    listeners[type] = listeners[type].filter(cb => cb !== callback);\n  }\n};\n\n// Close the WebSocket connection\nexport const closeWebSocket = () => {\n  if (socket) {\n    socket.close();\n    socket = null;\n  }\n\n  // Clear reconnect timer\n  if (reconnectTimer) {\n    clearTimeout(reconnectTimer);\n    reconnectTimer = null;\n  }\n\n  // Clear all listeners\n  listeners = {};\n};\n\n// Reconnect to WebSocket\nconst reconnect = () => {\n  if (reconnectTimer || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n      console.error(`Failed to reconnect after ${MAX_RECONNECT_ATTEMPTS} attempts`);\n    }\n    return;\n  }\n  reconnectAttempts++;\n  reconnectTimer = setTimeout(() => {\n    console.log(`Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);\n    reconnectTimer = null;\n    initWebSocket();\n  }, RECONNECT_DELAY);\n};","map":{"version":3,"names":["getToken","socket","listeners","reconnectTimer","reconnectAttempts","MAX_RECONNECT_ATTEMPTS","RECONNECT_DELAY","initWebSocket","close","token","console","error","apiUrl","process","env","REACT_APP_API_URL","wsBase","replace","wsUrl","log","WebSocket","addEventListener","clearTimeout","event","data","jsonStr","message","JSON","parse","type","forEach","callback","e","reconnect","addListener","push","filter","cb","removeListener","closeWebSocket","setTimeout"],"sources":["/home/kdln/code/officestonks/frontend/src/services/websocket.js"],"sourcesContent":["// WebSocket service for real-time updates\nimport { getToken } from './auth';\n\nlet socket = null;\nlet listeners = {};\nlet reconnectTimer = null;\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst RECONNECT_DELAY = 3000; // 3 seconds\n\n// Initialize WebSocket connection\nexport const initWebSocket = () => {\n  if (socket) {\n    // Close existing connection before creating a new one\n    socket.close();\n  }\n\n  const token = getToken();\n  if (!token) {\n    console.error('No authentication token available for WebSocket connection');\n    return;\n  }\n\n  // Create WebSocket connection with token\n  // Get the backend URL from environment or default to Railway URL\n  const apiUrl = process.env.REACT_APP_API_URL || 'https://web-production-1e26.up.railway.app';\n\n  // Replace http/https with ws/wss\n  const wsBase = apiUrl.replace(/^http/, 'ws');\n\n  // Create the WebSocket URL\n  const wsUrl = `${wsBase}/ws?token=${token}`;\n\n  console.log('Connecting to WebSocket:', wsUrl);\n  socket = new WebSocket(wsUrl);\n\n  // Connection opened\n  socket.addEventListener('open', () => {\n    console.log('WebSocket connection established');\n    // Reset reconnect attempts on successful connection\n    reconnectAttempts = 0;\n    if (reconnectTimer) {\n      clearTimeout(reconnectTimer);\n      reconnectTimer = null;\n    }\n  });\n\n  // Listen for messages\n  socket.addEventListener('message', (event) => {\n    try {\n      // Log raw message for debugging\n      console.log('Raw WebSocket message:', event.data);\n\n      // Clean up the message if needed (in case there are control characters)\n      let jsonStr = event.data;\n      if (typeof jsonStr === 'string') {\n        // Remove any BOM and control characters\n        jsonStr = jsonStr.replace(/^\\ufeff/, ''); // Remove byte order mark\n        jsonStr = jsonStr.replace(/[\\x00-\\x1F\\x7F-\\x9F]/g, ''); // Remove control chars\n      }\n\n      const message = JSON.parse(jsonStr);\n\n      // Call all listeners for this message type\n      if (listeners[message.type]) {\n        listeners[message.type].forEach(callback => callback(message));\n      }\n\n      // Call general listeners\n      if (listeners['*']) {\n        listeners['*'].forEach(callback => callback(message));\n      }\n    } catch (e) {\n      console.error('Error parsing WebSocket message', e);\n      console.error('Message content:', event.data);\n      // Continue - don't let the error stop the socket\n    }\n  });\n\n  // Connection closed\n  socket.addEventListener('close', () => {\n    console.log('WebSocket connection closed');\n    // Attempt to reconnect\n    reconnect();\n  });\n\n  // Connection error\n  socket.addEventListener('error', (error) => {\n    console.error('WebSocket error:', error);\n    // Socket will automatically close after error\n  });\n\n  return socket;\n};\n\n// Add a listener for a specific message type\nexport const addListener = (type, callback) => {\n  if (!listeners[type]) {\n    listeners[type] = [];\n  }\n  listeners[type].push(callback);\n  \n  // Return function to remove this listener\n  return () => {\n    if (listeners[type]) {\n      listeners[type] = listeners[type].filter(cb => cb !== callback);\n    }\n  };\n};\n\n// Remove a listener\nexport const removeListener = (type, callback) => {\n  if (listeners[type]) {\n    listeners[type] = listeners[type].filter(cb => cb !== callback);\n  }\n};\n\n// Close the WebSocket connection\nexport const closeWebSocket = () => {\n  if (socket) {\n    socket.close();\n    socket = null;\n  }\n  \n  // Clear reconnect timer\n  if (reconnectTimer) {\n    clearTimeout(reconnectTimer);\n    reconnectTimer = null;\n  }\n  \n  // Clear all listeners\n  listeners = {};\n};\n\n// Reconnect to WebSocket\nconst reconnect = () => {\n  if (reconnectTimer || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n      console.error(`Failed to reconnect after ${MAX_RECONNECT_ATTEMPTS} attempts`);\n    }\n    return;\n  }\n  \n  reconnectAttempts++;\n  \n  reconnectTimer = setTimeout(() => {\n    console.log(`Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);\n    reconnectTimer = null;\n    initWebSocket();\n  }, RECONNECT_DELAY);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}