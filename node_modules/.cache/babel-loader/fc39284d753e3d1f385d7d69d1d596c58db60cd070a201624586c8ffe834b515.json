{"ast":null,"code":"// WebSocket service for real-time updates\nimport { getToken } from './auth';\nlet socket = null;\nlet listeners = {};\nlet reconnectTimer = null;\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst RECONNECT_DELAY = 3000; // 3 seconds\n\n// Initialize WebSocket connection\nexport const initWebSocket = () => {\n  if (socket) {\n    // Close existing connection before creating a new one\n    socket.close();\n  }\n  const token = getToken();\n  if (!token) {\n    console.error('No authentication token available for WebSocket connection');\n    return;\n  }\n\n  // Create WebSocket connection with token\n  // Get the backend URL from environment or default to Railway URL\n  const apiUrl = process.env.REACT_APP_API_URL || 'https://web-production-1e26.up.railway.app';\n\n  // Replace http/https with ws/wss\n  const wsBase = apiUrl.replace(/^http/, 'ws');\n\n  // Create the WebSocket URL\n  const wsUrl = `${wsBase}/ws?token=${token}`;\n  console.log('Connecting to WebSocket:', wsUrl);\n  socket = new WebSocket(wsUrl);\n\n  // Connection opened\n  socket.addEventListener('open', () => {\n    console.log('WebSocket connection established');\n    // Reset reconnect attempts on successful connection\n    reconnectAttempts = 0;\n    if (reconnectTimer) {\n      clearTimeout(reconnectTimer);\n      reconnectTimer = null;\n    }\n  });\n\n  // Listen for messages\n  socket.addEventListener('message', event => {\n    try {\n      // Log raw message for debugging\n      console.log('Raw WebSocket message:', event.data);\n\n      // Handle multiple JSON objects in a single message\n      let jsonStr = event.data;\n      if (typeof jsonStr === 'string') {\n        // Remove any BOM and control characters\n        jsonStr = jsonStr.replace(/^\\ufeff/, ''); // Remove byte order mark\n        jsonStr = jsonStr.replace(/[\\x00-\\x1F\\x7F-\\x9F]/g, ''); // Remove control chars\n\n        // Try to handle multiple JSON objects in a single message\n        if (jsonStr.includes('}{')) {\n          // Split the string by finding the end of one JSON object and the start of another\n          const messages = jsonStr.split(/(?<=})\\s*(?={)/);\n          console.log('Split into multiple messages:', messages);\n\n          // Process each message individually\n          messages.forEach(msg => {\n            try {\n              const parsedMsg = JSON.parse(msg);\n              processMessage(parsedMsg);\n            } catch (innerErr) {\n              console.error('Error parsing individual message:', innerErr);\n              console.error('Message content:', msg);\n            }\n          });\n          return; // We've handled the multiple messages\n        }\n      }\n\n      // Process a single JSON message\n      const message = JSON.parse(jsonStr);\n      processMessage(message);\n    } catch (e) {\n      console.error('Error parsing WebSocket message', e);\n      console.error('Message content:', event.data);\n\n      // Try to manually parse as multiple messages\n      try {\n        const messageStr = String(event.data);\n        // Find all possible JSON objects - very simplistic approach\n        const regex = /{[^{}]*\"type\"[^{}]*}/g;\n        const possibleMatches = messageStr.match(regex);\n        if (possibleMatches && possibleMatches.length > 0) {\n          console.log('Found potential JSON objects:', possibleMatches.length);\n          possibleMatches.forEach(match => {\n            try {\n              const parsedMsg = JSON.parse(match);\n              console.log('Successfully parsed match:', parsedMsg);\n              processMessage(parsedMsg);\n            } catch (matchErr) {\n              console.log('Failed to parse match:', match);\n            }\n          });\n        }\n      } catch (fallbackErr) {\n        console.error('Fallback parsing also failed:', fallbackErr);\n      }\n\n      // Continue - don't let the error stop the socket\n    }\n  });\n\n  // Connection closed\n  socket.addEventListener('close', () => {\n    console.log('WebSocket connection closed');\n    // Attempt to reconnect\n    reconnect();\n  });\n\n  // Connection error\n  socket.addEventListener('error', error => {\n    console.error('WebSocket error:', error);\n    // Socket will automatically close after error\n  });\n  return socket;\n};\n\n// Helper function to process a single parsed message\nfunction processMessage(message) {\n  // Call all listeners for this message type\n  if (listeners[message.type]) {\n    listeners[message.type].forEach(callback => callback(message));\n  }\n\n  // Call general listeners\n  if (listeners['*']) {\n    listeners['*'].forEach(callback => callback(message));\n  }\n}\n\n// Add a listener for a specific message type\nexport const addListener = (type, callback) => {\n  if (!listeners[type]) {\n    listeners[type] = [];\n  }\n  listeners[type].push(callback);\n\n  // Return function to remove this listener\n  return () => {\n    if (listeners[type]) {\n      listeners[type] = listeners[type].filter(cb => cb !== callback);\n    }\n  };\n};\n\n// Remove a listener\nexport const removeListener = (type, callback) => {\n  if (listeners[type]) {\n    listeners[type] = listeners[type].filter(cb => cb !== callback);\n  }\n};\n\n// Close the WebSocket connection\nexport const closeWebSocket = () => {\n  if (socket) {\n    socket.close();\n    socket = null;\n  }\n\n  // Clear reconnect timer\n  if (reconnectTimer) {\n    clearTimeout(reconnectTimer);\n    reconnectTimer = null;\n  }\n\n  // Clear all listeners\n  listeners = {};\n};\n\n// Reconnect to WebSocket\nconst reconnect = () => {\n  if (reconnectTimer || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n      console.error(`Failed to reconnect after ${MAX_RECONNECT_ATTEMPTS} attempts`);\n    }\n    return;\n  }\n  reconnectAttempts++;\n  reconnectTimer = setTimeout(() => {\n    console.log(`Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);\n    reconnectTimer = null;\n    initWebSocket();\n  }, RECONNECT_DELAY);\n};","map":{"version":3,"names":["getToken","socket","listeners","reconnectTimer","reconnectAttempts","MAX_RECONNECT_ATTEMPTS","RECONNECT_DELAY","initWebSocket","close","token","console","error","apiUrl","process","env","REACT_APP_API_URL","wsBase","replace","wsUrl","log","WebSocket","addEventListener","clearTimeout","event","data","jsonStr","includes","messages","split","forEach","msg","parsedMsg","JSON","parse","processMessage","innerErr","message","e","messageStr","String","regex","possibleMatches","match","length","matchErr","fallbackErr","reconnect","type","callback","addListener","push","filter","cb","removeListener","closeWebSocket","setTimeout"],"sources":["/home/kdln/code/officestonks/frontend/src/services/websocket.js"],"sourcesContent":["// WebSocket service for real-time updates\nimport { getToken } from './auth';\n\nlet socket = null;\nlet listeners = {};\nlet reconnectTimer = null;\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst RECONNECT_DELAY = 3000; // 3 seconds\n\n// Initialize WebSocket connection\nexport const initWebSocket = () => {\n  if (socket) {\n    // Close existing connection before creating a new one\n    socket.close();\n  }\n\n  const token = getToken();\n  if (!token) {\n    console.error('No authentication token available for WebSocket connection');\n    return;\n  }\n\n  // Create WebSocket connection with token\n  // Get the backend URL from environment or default to Railway URL\n  const apiUrl = process.env.REACT_APP_API_URL || 'https://web-production-1e26.up.railway.app';\n\n  // Replace http/https with ws/wss\n  const wsBase = apiUrl.replace(/^http/, 'ws');\n\n  // Create the WebSocket URL\n  const wsUrl = `${wsBase}/ws?token=${token}`;\n\n  console.log('Connecting to WebSocket:', wsUrl);\n  socket = new WebSocket(wsUrl);\n\n  // Connection opened\n  socket.addEventListener('open', () => {\n    console.log('WebSocket connection established');\n    // Reset reconnect attempts on successful connection\n    reconnectAttempts = 0;\n    if (reconnectTimer) {\n      clearTimeout(reconnectTimer);\n      reconnectTimer = null;\n    }\n  });\n\n  // Listen for messages\n  socket.addEventListener('message', (event) => {\n    try {\n      // Log raw message for debugging\n      console.log('Raw WebSocket message:', event.data);\n      \n      // Handle multiple JSON objects in a single message\n      let jsonStr = event.data;\n      if (typeof jsonStr === 'string') {\n        // Remove any BOM and control characters\n        jsonStr = jsonStr.replace(/^\\ufeff/, ''); // Remove byte order mark\n        jsonStr = jsonStr.replace(/[\\x00-\\x1F\\x7F-\\x9F]/g, ''); // Remove control chars\n        \n        // Try to handle multiple JSON objects in a single message\n        if (jsonStr.includes('}{')) {\n          // Split the string by finding the end of one JSON object and the start of another\n          const messages = jsonStr.split(/(?<=})\\s*(?={)/);\n          console.log('Split into multiple messages:', messages);\n          \n          // Process each message individually\n          messages.forEach(msg => {\n            try {\n              const parsedMsg = JSON.parse(msg);\n              processMessage(parsedMsg);\n            } catch (innerErr) {\n              console.error('Error parsing individual message:', innerErr);\n              console.error('Message content:', msg);\n            }\n          });\n          return; // We've handled the multiple messages\n        }\n      }\n      \n      // Process a single JSON message\n      const message = JSON.parse(jsonStr);\n      processMessage(message);\n    } catch (e) {\n      console.error('Error parsing WebSocket message', e);\n      console.error('Message content:', event.data);\n      \n      // Try to manually parse as multiple messages\n      try {\n        const messageStr = String(event.data);\n        // Find all possible JSON objects - very simplistic approach\n        const regex = /{[^{}]*\"type\"[^{}]*}/g;\n        const possibleMatches = messageStr.match(regex);\n        \n        if (possibleMatches && possibleMatches.length > 0) {\n          console.log('Found potential JSON objects:', possibleMatches.length);\n          possibleMatches.forEach(match => {\n            try {\n              const parsedMsg = JSON.parse(match);\n              console.log('Successfully parsed match:', parsedMsg);\n              processMessage(parsedMsg);\n            } catch (matchErr) {\n              console.log('Failed to parse match:', match);\n            }\n          });\n        }\n      } catch (fallbackErr) {\n        console.error('Fallback parsing also failed:', fallbackErr);\n      }\n      \n      // Continue - don't let the error stop the socket\n    }\n  });\n  \n  // Connection closed\n  socket.addEventListener('close', () => {\n    console.log('WebSocket connection closed');\n    // Attempt to reconnect\n    reconnect();\n  });\n\n  // Connection error\n  socket.addEventListener('error', (error) => {\n    console.error('WebSocket error:', error);\n    // Socket will automatically close after error\n  });\n\n  return socket;\n};\n\n// Helper function to process a single parsed message\nfunction processMessage(message) {\n  // Call all listeners for this message type\n  if (listeners[message.type]) {\n    listeners[message.type].forEach(callback => callback(message));\n  }\n  \n  // Call general listeners\n  if (listeners['*']) {\n    listeners['*'].forEach(callback => callback(message));\n  }\n}\n\n// Add a listener for a specific message type\nexport const addListener = (type, callback) => {\n  if (!listeners[type]) {\n    listeners[type] = [];\n  }\n  listeners[type].push(callback);\n  \n  // Return function to remove this listener\n  return () => {\n    if (listeners[type]) {\n      listeners[type] = listeners[type].filter(cb => cb !== callback);\n    }\n  };\n};\n\n// Remove a listener\nexport const removeListener = (type, callback) => {\n  if (listeners[type]) {\n    listeners[type] = listeners[type].filter(cb => cb !== callback);\n  }\n};\n\n// Close the WebSocket connection\nexport const closeWebSocket = () => {\n  if (socket) {\n    socket.close();\n    socket = null;\n  }\n  \n  // Clear reconnect timer\n  if (reconnectTimer) {\n    clearTimeout(reconnectTimer);\n    reconnectTimer = null;\n  }\n  \n  // Clear all listeners\n  listeners = {};\n};\n\n// Reconnect to WebSocket\nconst reconnect = () => {\n  if (reconnectTimer || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n      console.error(`Failed to reconnect after ${MAX_RECONNECT_ATTEMPTS} attempts`);\n    }\n    return;\n  }\n  \n  reconnectAttempts++;\n  \n  reconnectTimer = setTimeout(() => {\n    console.log(`Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);\n    reconnectTimer = null;\n    initWebSocket();\n  }, RECONNECT_DELAY);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}