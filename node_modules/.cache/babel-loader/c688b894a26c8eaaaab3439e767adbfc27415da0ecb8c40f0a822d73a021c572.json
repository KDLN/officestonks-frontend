{"ast":null,"code":"// WebSocket service for real-time updates\nimport{getToken}from'./auth';let socket=null;let listeners={};let reconnectTimer=null;let reconnectAttempts=0;const MAX_RECONNECT_ATTEMPTS=5;const RECONNECT_DELAY=3000;// 3 seconds\n// Initialize WebSocket connection\nexport const initWebSocket=()=>{if(socket){// Close existing connection before creating a new one\nsocket.close();}// Socket will be initialized below\nconst token=getToken();if(!token){console.error('No authentication token available for WebSocket connection');return;}// Create WebSocket connection with token\n// Get the backend URL from environment or default to Railway URL\nconst apiUrl=process.env.REACT_APP_API_URL||'https://web-copy-production-5b48.up.railway.app';// Replace http/https with ws/wss\nconst wsBase=apiUrl.replace(/^http/,'ws');// Create the WebSocket URL\nconst wsUrl=`${wsBase}/ws?token=${token}`;console.log('Connecting to WebSocket:',wsUrl);socket=new WebSocket(wsUrl);// Make socket and addListener available globally for other components\nwindow.socket=socket;window.addListener=addListener;// Connection opened\nsocket.addEventListener('open',()=>{console.log('WebSocket connection established');// Reset reconnect attempts on successful connection\nreconnectAttempts=0;if(reconnectTimer){clearTimeout(reconnectTimer);reconnectTimer=null;}});// Listen for messages\nsocket.addEventListener('message',event=>{try{// Log raw message for debugging\nconsole.log('Raw WebSocket message:',event.data);// Clean the message string\nlet jsonStr=event.data;if(typeof jsonStr==='string'){// Remove any BOM and control characters\njsonStr=jsonStr.replace(/^\\ufeff/,'');// Remove byte order mark\njsonStr=jsonStr.replace(/[\\x00-\\x1F\\x7F-\\x9F]/g,'');// Remove control chars except whitespace\njsonStr=jsonStr.trim();// Remove leading/trailing whitespace\n// Backend should now send each message separately, but keep handling for robustness\nif(jsonStr.includes('}{')){console.log('Found multiple JSON objects in message - splitting');// Split by finding object boundaries - this handles nested objects better\nlet objects=[];let nesting=0;let start=0;for(let i=0;i<jsonStr.length;i++){if(jsonStr[i]==='{'){if(nesting===0)start=i;nesting++;}else if(jsonStr[i]==='}'){nesting--;if(nesting===0){// Extract complete object\nobjects.push(jsonStr.substring(start,i+1));}}}console.log(`Split into ${objects.length} JSON objects`);// Process each message individually\nobjects.forEach(jsonObj=>{try{const parsedObj=JSON.parse(jsonObj);processMessage(parsedObj);}catch(innerErr){console.error('Error parsing individual JSON object:',innerErr);console.error('Object content:',jsonObj);}});return;// We've handled the multiple objects\n}}// Process a single JSON message\ntry{const message=JSON.parse(jsonStr);processMessage(message);}catch(parseError){throw new Error(`Failed to parse JSON: ${parseError.message}`);}}catch(e){console.error('Error processing WebSocket message:',e);console.error('Message content:',event.data);// Final fallback attempt for malformed messages\ntry{// Sometimes we might receive messages with extra characters or incorrect format\n// Try to extract valid JSON objects using a regex\nconst messageStr=String(event.data);const regex=/({[^}]+})/g;const matches=messageStr.match(regex);if(matches&&matches.length>0){console.log('Fallback: Found potential JSON objects:',matches.length);matches.forEach(match=>{try{// Try to clean and parse each match\nconst cleanMatch=match.replace(/[^\\x20-\\x7E]/g,'');const parsedMsg=JSON.parse(cleanMatch);console.log('Successfully parsed from fallback:',parsedMsg);processMessage(parsedMsg);}catch(matchErr){// Just log and continue\nconsole.log('Failed to parse potential object:',match);}});}}catch(fallbackErr){console.error('All parsing attempts failed');}}});// Connection closed\nsocket.addEventListener('close',()=>{console.log('WebSocket connection closed');// Attempt to reconnect\nreconnect();});// Connection error\nsocket.addEventListener('error',error=>{console.error('WebSocket error:',error);// Socket will automatically close after error\n});return socket;};// Helper function to process a single parsed message\nfunction processMessage(message){// Call all listeners for this message type\nif(listeners[message.type]){listeners[message.type].forEach(callback=>callback(message));}// Call general listeners\nif(listeners['*']){listeners['*'].forEach(callback=>callback(message));}}// Add a listener for a specific message type\nexport const addListener=(type,callback)=>{if(!listeners[type]){listeners[type]=[];}listeners[type].push(callback);// Return function to remove this listener\nreturn()=>{if(listeners[type]){listeners[type]=listeners[type].filter(cb=>cb!==callback);}};};// Remove a listener\nexport const removeListener=(type,callback)=>{if(listeners[type]){listeners[type]=listeners[type].filter(cb=>cb!==callback);}};// Close the WebSocket connection\nexport const closeWebSocket=()=>{if(socket){socket.close();socket=null;}// Clear reconnect timer\nif(reconnectTimer){clearTimeout(reconnectTimer);reconnectTimer=null;}// Clear all listeners\nlisteners={};};// Reconnect to WebSocket\nconst reconnect=()=>{if(reconnectTimer||reconnectAttempts>=MAX_RECONNECT_ATTEMPTS){if(reconnectAttempts>=MAX_RECONNECT_ATTEMPTS){console.error(`Failed to reconnect after ${MAX_RECONNECT_ATTEMPTS} attempts`);}return;}reconnectAttempts++;reconnectTimer=setTimeout(()=>{console.log(`Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);reconnectTimer=null;initWebSocket();},RECONNECT_DELAY);};","map":{"version":3,"names":["getToken","socket","listeners","reconnectTimer","reconnectAttempts","MAX_RECONNECT_ATTEMPTS","RECONNECT_DELAY","initWebSocket","close","token","console","error","apiUrl","process","env","REACT_APP_API_URL","wsBase","replace","wsUrl","log","WebSocket","window","addListener","addEventListener","clearTimeout","event","data","jsonStr","trim","includes","objects","nesting","start","i","length","push","substring","forEach","jsonObj","parsedObj","JSON","parse","processMessage","innerErr","message","parseError","Error","e","messageStr","String","regex","matches","match","cleanMatch","parsedMsg","matchErr","fallbackErr","reconnect","type","callback","filter","cb","removeListener","closeWebSocket","setTimeout"],"sources":["/home/kdln/code/officestonks/frontend/src/services/websocket.js"],"sourcesContent":["// WebSocket service for real-time updates\nimport { getToken } from './auth';\n\nlet socket = null;\nlet listeners = {};\nlet reconnectTimer = null;\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst RECONNECT_DELAY = 3000; // 3 seconds\n\n// Initialize WebSocket connection\nexport const initWebSocket = () => {\n  if (socket) {\n    // Close existing connection before creating a new one\n    socket.close();\n  }\n\n  // Socket will be initialized below\n\n  const token = getToken();\n  if (!token) {\n    console.error('No authentication token available for WebSocket connection');\n    return;\n  }\n\n  // Create WebSocket connection with token\n  // Get the backend URL from environment or default to Railway URL\n  const apiUrl = process.env.REACT_APP_API_URL || 'https://web-copy-production-5b48.up.railway.app';\n\n  // Replace http/https with ws/wss\n  const wsBase = apiUrl.replace(/^http/, 'ws');\n\n  // Create the WebSocket URL\n  const wsUrl = `${wsBase}/ws?token=${token}`;\n\n  console.log('Connecting to WebSocket:', wsUrl);\n  socket = new WebSocket(wsUrl);\n\n  // Make socket and addListener available globally for other components\n  window.socket = socket;\n  window.addListener = addListener;\n\n  // Connection opened\n  socket.addEventListener('open', () => {\n    console.log('WebSocket connection established');\n    // Reset reconnect attempts on successful connection\n    reconnectAttempts = 0;\n    if (reconnectTimer) {\n      clearTimeout(reconnectTimer);\n      reconnectTimer = null;\n    }\n  });\n\n  // Listen for messages\n  socket.addEventListener('message', (event) => {\n    try {\n      // Log raw message for debugging\n      console.log('Raw WebSocket message:', event.data);\n\n      // Clean the message string\n      let jsonStr = event.data;\n      if (typeof jsonStr === 'string') {\n        // Remove any BOM and control characters\n        jsonStr = jsonStr.replace(/^\\ufeff/, ''); // Remove byte order mark\n        jsonStr = jsonStr.replace(/[\\x00-\\x1F\\x7F-\\x9F]/g, ''); // Remove control chars except whitespace\n        jsonStr = jsonStr.trim(); // Remove leading/trailing whitespace\n\n        // Backend should now send each message separately, but keep handling for robustness\n        if (jsonStr.includes('}{')) {\n          console.log('Found multiple JSON objects in message - splitting');\n\n          // Split by finding object boundaries - this handles nested objects better\n          let objects = [];\n          let nesting = 0;\n          let start = 0;\n\n          for (let i = 0; i < jsonStr.length; i++) {\n            if (jsonStr[i] === '{') {\n              if (nesting === 0) start = i;\n              nesting++;\n            } else if (jsonStr[i] === '}') {\n              nesting--;\n              if (nesting === 0) {\n                // Extract complete object\n                objects.push(jsonStr.substring(start, i + 1));\n              }\n            }\n          }\n\n          console.log(`Split into ${objects.length} JSON objects`);\n\n          // Process each message individually\n          objects.forEach(jsonObj => {\n            try {\n              const parsedObj = JSON.parse(jsonObj);\n              processMessage(parsedObj);\n            } catch (innerErr) {\n              console.error('Error parsing individual JSON object:', innerErr);\n              console.error('Object content:', jsonObj);\n            }\n          });\n\n          return; // We've handled the multiple objects\n        }\n      }\n\n      // Process a single JSON message\n      try {\n        const message = JSON.parse(jsonStr);\n        processMessage(message);\n      } catch (parseError) {\n        throw new Error(`Failed to parse JSON: ${parseError.message}`);\n      }\n    } catch (e) {\n      console.error('Error processing WebSocket message:', e);\n      console.error('Message content:', event.data);\n\n      // Final fallback attempt for malformed messages\n      try {\n        // Sometimes we might receive messages with extra characters or incorrect format\n        // Try to extract valid JSON objects using a regex\n        const messageStr = String(event.data);\n        const regex = /({[^}]+})/g;\n        const matches = messageStr.match(regex);\n\n        if (matches && matches.length > 0) {\n          console.log('Fallback: Found potential JSON objects:', matches.length);\n          matches.forEach(match => {\n            try {\n              // Try to clean and parse each match\n              const cleanMatch = match.replace(/[^\\x20-\\x7E]/g, '');\n              const parsedMsg = JSON.parse(cleanMatch);\n              console.log('Successfully parsed from fallback:', parsedMsg);\n              processMessage(parsedMsg);\n            } catch (matchErr) {\n              // Just log and continue\n              console.log('Failed to parse potential object:', match);\n            }\n          });\n        }\n      } catch (fallbackErr) {\n        console.error('All parsing attempts failed');\n      }\n    }\n  });\n  \n  // Connection closed\n  socket.addEventListener('close', () => {\n    console.log('WebSocket connection closed');\n    // Attempt to reconnect\n    reconnect();\n  });\n\n  // Connection error\n  socket.addEventListener('error', (error) => {\n    console.error('WebSocket error:', error);\n    // Socket will automatically close after error\n  });\n\n  return socket;\n};\n\n// Helper function to process a single parsed message\nfunction processMessage(message) {\n  // Call all listeners for this message type\n  if (listeners[message.type]) {\n    listeners[message.type].forEach(callback => callback(message));\n  }\n  \n  // Call general listeners\n  if (listeners['*']) {\n    listeners['*'].forEach(callback => callback(message));\n  }\n}\n\n// Add a listener for a specific message type\nexport const addListener = (type, callback) => {\n  if (!listeners[type]) {\n    listeners[type] = [];\n  }\n  listeners[type].push(callback);\n  \n  // Return function to remove this listener\n  return () => {\n    if (listeners[type]) {\n      listeners[type] = listeners[type].filter(cb => cb !== callback);\n    }\n  };\n};\n\n// Remove a listener\nexport const removeListener = (type, callback) => {\n  if (listeners[type]) {\n    listeners[type] = listeners[type].filter(cb => cb !== callback);\n  }\n};\n\n// Close the WebSocket connection\nexport const closeWebSocket = () => {\n  if (socket) {\n    socket.close();\n    socket = null;\n  }\n  \n  // Clear reconnect timer\n  if (reconnectTimer) {\n    clearTimeout(reconnectTimer);\n    reconnectTimer = null;\n  }\n  \n  // Clear all listeners\n  listeners = {};\n};\n\n// Reconnect to WebSocket\nconst reconnect = () => {\n  if (reconnectTimer || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n      console.error(`Failed to reconnect after ${MAX_RECONNECT_ATTEMPTS} attempts`);\n    }\n    return;\n  }\n  \n  reconnectAttempts++;\n  \n  reconnectTimer = setTimeout(() => {\n    console.log(`Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);\n    reconnectTimer = null;\n    initWebSocket();\n  }, RECONNECT_DELAY);\n};"],"mappings":"AAAA;AACA,OAASA,QAAQ,KAAQ,QAAQ,CAEjC,GAAI,CAAAC,MAAM,CAAG,IAAI,CACjB,GAAI,CAAAC,SAAS,CAAG,CAAC,CAAC,CAClB,GAAI,CAAAC,cAAc,CAAG,IAAI,CACzB,GAAI,CAAAC,iBAAiB,CAAG,CAAC,CACzB,KAAM,CAAAC,sBAAsB,CAAG,CAAC,CAChC,KAAM,CAAAC,eAAe,CAAG,IAAI,CAAE;AAE9B;AACA,MAAO,MAAM,CAAAC,aAAa,CAAGA,CAAA,GAAM,CACjC,GAAIN,MAAM,CAAE,CACV;AACAA,MAAM,CAACO,KAAK,CAAC,CAAC,CAChB,CAEA;AAEA,KAAM,CAAAC,KAAK,CAAGT,QAAQ,CAAC,CAAC,CACxB,GAAI,CAACS,KAAK,CAAE,CACVC,OAAO,CAACC,KAAK,CAAC,4DAA4D,CAAC,CAC3E,OACF,CAEA;AACA;AACA,KAAM,CAAAC,MAAM,CAAGC,OAAO,CAACC,GAAG,CAACC,iBAAiB,EAAI,iDAAiD,CAEjG;AACA,KAAM,CAAAC,MAAM,CAAGJ,MAAM,CAACK,OAAO,CAAC,OAAO,CAAE,IAAI,CAAC,CAE5C;AACA,KAAM,CAAAC,KAAK,CAAG,GAAGF,MAAM,aAAaP,KAAK,EAAE,CAE3CC,OAAO,CAACS,GAAG,CAAC,0BAA0B,CAAED,KAAK,CAAC,CAC9CjB,MAAM,CAAG,GAAI,CAAAmB,SAAS,CAACF,KAAK,CAAC,CAE7B;AACAG,MAAM,CAACpB,MAAM,CAAGA,MAAM,CACtBoB,MAAM,CAACC,WAAW,CAAGA,WAAW,CAEhC;AACArB,MAAM,CAACsB,gBAAgB,CAAC,MAAM,CAAE,IAAM,CACpCb,OAAO,CAACS,GAAG,CAAC,kCAAkC,CAAC,CAC/C;AACAf,iBAAiB,CAAG,CAAC,CACrB,GAAID,cAAc,CAAE,CAClBqB,YAAY,CAACrB,cAAc,CAAC,CAC5BA,cAAc,CAAG,IAAI,CACvB,CACF,CAAC,CAAC,CAEF;AACAF,MAAM,CAACsB,gBAAgB,CAAC,SAAS,CAAGE,KAAK,EAAK,CAC5C,GAAI,CACF;AACAf,OAAO,CAACS,GAAG,CAAC,wBAAwB,CAAEM,KAAK,CAACC,IAAI,CAAC,CAEjD;AACA,GAAI,CAAAC,OAAO,CAAGF,KAAK,CAACC,IAAI,CACxB,GAAI,MAAO,CAAAC,OAAO,GAAK,QAAQ,CAAE,CAC/B;AACAA,OAAO,CAAGA,OAAO,CAACV,OAAO,CAAC,SAAS,CAAE,EAAE,CAAC,CAAE;AAC1CU,OAAO,CAAGA,OAAO,CAACV,OAAO,CAAC,uBAAuB,CAAE,EAAE,CAAC,CAAE;AACxDU,OAAO,CAAGA,OAAO,CAACC,IAAI,CAAC,CAAC,CAAE;AAE1B;AACA,GAAID,OAAO,CAACE,QAAQ,CAAC,IAAI,CAAC,CAAE,CAC1BnB,OAAO,CAACS,GAAG,CAAC,oDAAoD,CAAC,CAEjE;AACA,GAAI,CAAAW,OAAO,CAAG,EAAE,CAChB,GAAI,CAAAC,OAAO,CAAG,CAAC,CACf,GAAI,CAAAC,KAAK,CAAG,CAAC,CAEb,IAAK,GAAI,CAAAC,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGN,OAAO,CAACO,MAAM,CAAED,CAAC,EAAE,CAAE,CACvC,GAAIN,OAAO,CAACM,CAAC,CAAC,GAAK,GAAG,CAAE,CACtB,GAAIF,OAAO,GAAK,CAAC,CAAEC,KAAK,CAAGC,CAAC,CAC5BF,OAAO,EAAE,CACX,CAAC,IAAM,IAAIJ,OAAO,CAACM,CAAC,CAAC,GAAK,GAAG,CAAE,CAC7BF,OAAO,EAAE,CACT,GAAIA,OAAO,GAAK,CAAC,CAAE,CACjB;AACAD,OAAO,CAACK,IAAI,CAACR,OAAO,CAACS,SAAS,CAACJ,KAAK,CAAEC,CAAC,CAAG,CAAC,CAAC,CAAC,CAC/C,CACF,CACF,CAEAvB,OAAO,CAACS,GAAG,CAAC,cAAcW,OAAO,CAACI,MAAM,eAAe,CAAC,CAExD;AACAJ,OAAO,CAACO,OAAO,CAACC,OAAO,EAAI,CACzB,GAAI,CACF,KAAM,CAAAC,SAAS,CAAGC,IAAI,CAACC,KAAK,CAACH,OAAO,CAAC,CACrCI,cAAc,CAACH,SAAS,CAAC,CAC3B,CAAE,MAAOI,QAAQ,CAAE,CACjBjC,OAAO,CAACC,KAAK,CAAC,uCAAuC,CAAEgC,QAAQ,CAAC,CAChEjC,OAAO,CAACC,KAAK,CAAC,iBAAiB,CAAE2B,OAAO,CAAC,CAC3C,CACF,CAAC,CAAC,CAEF,OAAQ;AACV,CACF,CAEA;AACA,GAAI,CACF,KAAM,CAAAM,OAAO,CAAGJ,IAAI,CAACC,KAAK,CAACd,OAAO,CAAC,CACnCe,cAAc,CAACE,OAAO,CAAC,CACzB,CAAE,MAAOC,UAAU,CAAE,CACnB,KAAM,IAAI,CAAAC,KAAK,CAAC,yBAAyBD,UAAU,CAACD,OAAO,EAAE,CAAC,CAChE,CACF,CAAE,MAAOG,CAAC,CAAE,CACVrC,OAAO,CAACC,KAAK,CAAC,qCAAqC,CAAEoC,CAAC,CAAC,CACvDrC,OAAO,CAACC,KAAK,CAAC,kBAAkB,CAAEc,KAAK,CAACC,IAAI,CAAC,CAE7C;AACA,GAAI,CACF;AACA;AACA,KAAM,CAAAsB,UAAU,CAAGC,MAAM,CAACxB,KAAK,CAACC,IAAI,CAAC,CACrC,KAAM,CAAAwB,KAAK,CAAG,YAAY,CAC1B,KAAM,CAAAC,OAAO,CAAGH,UAAU,CAACI,KAAK,CAACF,KAAK,CAAC,CAEvC,GAAIC,OAAO,EAAIA,OAAO,CAACjB,MAAM,CAAG,CAAC,CAAE,CACjCxB,OAAO,CAACS,GAAG,CAAC,yCAAyC,CAAEgC,OAAO,CAACjB,MAAM,CAAC,CACtEiB,OAAO,CAACd,OAAO,CAACe,KAAK,EAAI,CACvB,GAAI,CACF;AACA,KAAM,CAAAC,UAAU,CAAGD,KAAK,CAACnC,OAAO,CAAC,eAAe,CAAE,EAAE,CAAC,CACrD,KAAM,CAAAqC,SAAS,CAAGd,IAAI,CAACC,KAAK,CAACY,UAAU,CAAC,CACxC3C,OAAO,CAACS,GAAG,CAAC,oCAAoC,CAAEmC,SAAS,CAAC,CAC5DZ,cAAc,CAACY,SAAS,CAAC,CAC3B,CAAE,MAAOC,QAAQ,CAAE,CACjB;AACA7C,OAAO,CAACS,GAAG,CAAC,mCAAmC,CAAEiC,KAAK,CAAC,CACzD,CACF,CAAC,CAAC,CACJ,CACF,CAAE,MAAOI,WAAW,CAAE,CACpB9C,OAAO,CAACC,KAAK,CAAC,6BAA6B,CAAC,CAC9C,CACF,CACF,CAAC,CAAC,CAEF;AACAV,MAAM,CAACsB,gBAAgB,CAAC,OAAO,CAAE,IAAM,CACrCb,OAAO,CAACS,GAAG,CAAC,6BAA6B,CAAC,CAC1C;AACAsC,SAAS,CAAC,CAAC,CACb,CAAC,CAAC,CAEF;AACAxD,MAAM,CAACsB,gBAAgB,CAAC,OAAO,CAAGZ,KAAK,EAAK,CAC1CD,OAAO,CAACC,KAAK,CAAC,kBAAkB,CAAEA,KAAK,CAAC,CACxC;AACF,CAAC,CAAC,CAEF,MAAO,CAAAV,MAAM,CACf,CAAC,CAED;AACA,QAAS,CAAAyC,cAAcA,CAACE,OAAO,CAAE,CAC/B;AACA,GAAI1C,SAAS,CAAC0C,OAAO,CAACc,IAAI,CAAC,CAAE,CAC3BxD,SAAS,CAAC0C,OAAO,CAACc,IAAI,CAAC,CAACrB,OAAO,CAACsB,QAAQ,EAAIA,QAAQ,CAACf,OAAO,CAAC,CAAC,CAChE,CAEA;AACA,GAAI1C,SAAS,CAAC,GAAG,CAAC,CAAE,CAClBA,SAAS,CAAC,GAAG,CAAC,CAACmC,OAAO,CAACsB,QAAQ,EAAIA,QAAQ,CAACf,OAAO,CAAC,CAAC,CACvD,CACF,CAEA;AACA,MAAO,MAAM,CAAAtB,WAAW,CAAGA,CAACoC,IAAI,CAAEC,QAAQ,GAAK,CAC7C,GAAI,CAACzD,SAAS,CAACwD,IAAI,CAAC,CAAE,CACpBxD,SAAS,CAACwD,IAAI,CAAC,CAAG,EAAE,CACtB,CACAxD,SAAS,CAACwD,IAAI,CAAC,CAACvB,IAAI,CAACwB,QAAQ,CAAC,CAE9B;AACA,MAAO,IAAM,CACX,GAAIzD,SAAS,CAACwD,IAAI,CAAC,CAAE,CACnBxD,SAAS,CAACwD,IAAI,CAAC,CAAGxD,SAAS,CAACwD,IAAI,CAAC,CAACE,MAAM,CAACC,EAAE,EAAIA,EAAE,GAAKF,QAAQ,CAAC,CACjE,CACF,CAAC,CACH,CAAC,CAED;AACA,MAAO,MAAM,CAAAG,cAAc,CAAGA,CAACJ,IAAI,CAAEC,QAAQ,GAAK,CAChD,GAAIzD,SAAS,CAACwD,IAAI,CAAC,CAAE,CACnBxD,SAAS,CAACwD,IAAI,CAAC,CAAGxD,SAAS,CAACwD,IAAI,CAAC,CAACE,MAAM,CAACC,EAAE,EAAIA,EAAE,GAAKF,QAAQ,CAAC,CACjE,CACF,CAAC,CAED;AACA,MAAO,MAAM,CAAAI,cAAc,CAAGA,CAAA,GAAM,CAClC,GAAI9D,MAAM,CAAE,CACVA,MAAM,CAACO,KAAK,CAAC,CAAC,CACdP,MAAM,CAAG,IAAI,CACf,CAEA;AACA,GAAIE,cAAc,CAAE,CAClBqB,YAAY,CAACrB,cAAc,CAAC,CAC5BA,cAAc,CAAG,IAAI,CACvB,CAEA;AACAD,SAAS,CAAG,CAAC,CAAC,CAChB,CAAC,CAED;AACA,KAAM,CAAAuD,SAAS,CAAGA,CAAA,GAAM,CACtB,GAAItD,cAAc,EAAIC,iBAAiB,EAAIC,sBAAsB,CAAE,CACjE,GAAID,iBAAiB,EAAIC,sBAAsB,CAAE,CAC/CK,OAAO,CAACC,KAAK,CAAC,6BAA6BN,sBAAsB,WAAW,CAAC,CAC/E,CACA,OACF,CAEAD,iBAAiB,EAAE,CAEnBD,cAAc,CAAG6D,UAAU,CAAC,IAAM,CAChCtD,OAAO,CAACS,GAAG,CAAC,4BAA4Bf,iBAAiB,IAAIC,sBAAsB,MAAM,CAAC,CAC1FF,cAAc,CAAG,IAAI,CACrBI,aAAa,CAAC,CAAC,CACjB,CAAC,CAAED,eAAe,CAAC,CACrB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}